import click
from tqdm import tqdm

from perfetto_wrapper import TProcess, TThread, TTrace, get_unique_uuid


@click.command(
    name="visualize_viz",
    help="Transforms a viz file generated by logGOPSSim to a perfetto trace file, which can then be loaded into perfetto to visualize interactions",
)
@click.argument(
    "in_file", type=click.Path(exists=True, dir_okay=False, resolve_path=True)
)
@click.argument(
    "out_file", type=click.Path(exists=False, dir_okay=False, resolve_path=True)
)
def cli(in_file, out_file):
    with open(in_file, "r") as f:
        # extrace the num of ranks and total no of lines
        lines = f.readlines()
        no_lines = len(lines)
        numranks = int(lines[0][0:-2].split(" ")[1])

        # Create an overarching process
        process = TProcess(0, "Network Execution")
        # create a thread for each rank
        threads = [TThread(i + 1, f"Rank {i}") for i in range(numranks)]

        # parse the remaining lines
        pbar = tqdm(total=(no_lines - 1))
        for line in lines[1:]:
            params = line.split(" ")
            op = params[0]
            args = params[1:]

            if op == "transmission":
                # Extract args
                src = int(args[0])
                dst = int(args[1])
                start = int(args[2])
                end = int(args[3])
                size = int(args[4])

                flow_id = get_unique_uuid()

                send_candidates = [
                    (i, t)
                    for (i, t) in enumerate(threads[src].event_params)
                    if t[5] == "osend" and t[2] <= start
                ]
                # Add flow_id to send event
                if send_candidates:
                    (send_id, send_t) = max(
                        send_candidates,
                        key=lambda t: t[1][2],
                    )
                    threads[src].event_params[send_id] = (
                        send_t[0],
                        send_t[1],
                        send_t[2],
                        send_t[3],
                        [flow_id],
                        send_t[5],
                    )
                else:
                    threads[src].add_event(
                        "transmission start",
                        estart=start,
                        eend=start + 1,
                        flow_ids=[flow_id],
                    )

                recv_candidates = [
                    (i, t)
                    for (i, t) in enumerate(threads[dst].event_params)
                    if t[5] == "orecv" and t[1] <= end
                ]
                # Add flow_id to recv event
                if recv_candidates:
                    recv_candidate = max(
                        recv_candidates,
                        key=lambda t: t[1][2],
                    )
                    (recv_id, recv_t) = recv_candidate
                    threads[dst].event_params[recv_id] = (
                        recv_t[0],
                        recv_t[1],
                        recv_t[2],
                        recv_t[3],
                        [flow_id],
                        recv_t[5],
                    )
                else:
                    threads[dst].add_event(
                        "transmission end",
                        estart=end,
                        eend=end + 1,
                        flow_ids=[flow_id],
                    )
            else:
                # Extract args
                rank = int(args[0])
                cpu = int(args[1])
                start = int(args[2])
                end = int(args[3])

                thread = threads[rank]

                # Add interaction
                if op == "osend":
                    thread.add_event("Send", estart=start, eend=end, op=op)
                elif op == "orecv":
                    thread.add_event("Receive", estart=start, eend=end, op=op)
                elif op == "loclop":
                    thread.add_event("Computing", estart=start, eend=end, op=op)
                elif op == "noise":
                    # TODO pjordan: Remove this?
                    # thread.add_event("Noise", estart=start, eend=end, op=op)
                    pass

            pbar.update(1)

        # Add all our threads to our process
        for i, t in enumerate(threads):
            process.add_thread(i, t)

        # Finally serialize the trace file
        trace = TTrace()
        trace.inject([process])
        trace.serialize_to_file(out_file)
    pass


if __name__ == "__main__":
    cli()
